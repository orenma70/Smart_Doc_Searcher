from flask import Flask, request, jsonify
from google import genai
from google.cloud import storage
from pypdf import PdfReader
import os
import io
import traceback

# --- ×”×’×“×¨×•×ª ---
app = Flask(__name__)
# ×”×’×‘×œ×ª ×’×•×“×œ: ××’×‘×™×œ ×›×œ ××¡××š ×‘-Prompt ×œ-10,000 ×ª×•×•×™× (×›×“×™ ×œ×× ×•×¢ ×©×’×™××ª Token Limit)
MAX_CHARS_PER_DOC = 10000

# ×§×‘×œ×ª ××©×ª× ×™ ×¡×‘×™×‘×”
BUCKET_NAME = os.getenv("BUCKET_NAME")
API_KEY = os.getenv("GEMINI_API_KEY")

# --- ××ª×—×•×œ ×œ×§×•×—×•×ª ---
try:
    if not API_KEY:
        raise ValueError("GEMINI_API_KEY environment variable not set.")
    genai_client = genai.Client(api_key=API_KEY)
    storage_client = storage.Client()
    print("âœ… Gemini and Storage clients initialized successfully.")
except Exception as e:
    # ×× ×”××ª×—×•×œ × ×›×©×œ (×œ××©×œ, ×—×¡×¨ ××¤×ª×—), ×”×©×¨×ª ×§×•×¨×¡ ×¢× ×”×•×“×¢×” ××¤×•×¨×˜×ª (×‘××§×•× 503 ×©×§×˜)
    print(f"FATAL ERROR during startup client initialization: {e}")
    traceback.print_exc()
    raise


def extract_content(blob_bytes, blob_name):
    """Extracts text content from bytes, handling different file types."""

    # 1. ×˜×™×¤×•×œ ×‘×§×‘×¦×™ PDF (×“×•×¨×© ××ª pypdf)
    if blob_name.lower().endswith('.pdf'):
        try:
            reader = PdfReader(io.BytesIO(blob_bytes))
            text = ""
            for page in reader.pages:
                text += page.extract_text() or ""
            return text
        except Exception as e:
            print(f"Error reading PDF {blob_name}: {e}")
            return "ERROR: Could not read PDF content."

    # 2. ×˜×™×¤×•×œ ×‘×§×‘×¦×™ ×˜×§×¡×˜ ×¨×’×™×œ×™× (txt, etc.)
    try:
        return blob_bytes.decode('utf-8', errors='ignore')
    except Exception as e:
        print(f"Error decoding text file {blob_name}: {e}")
        return "ERROR: Could not decode text content."


# ×”×¤×•× ×§×¦×™×” ×”××¨×›×–×™×ª ×œ×©×œ×™×¤×ª ××¡××›×™× ×-GCS
def get_gcs_files(directory_path, bucket_name):
    """Fetch files from a specific directory path in the GCS bucket."""
    print(f"ğŸ” Fetching files from gs://{bucket_name}/{directory_path}/")
    bucket = storage_client.bucket(bucket_name)

    prefix = f"{directory_path}/"
    blobs = bucket.list_blobs(prefix=prefix)

    file_data = []

    for blob in blobs:
        # ×‘×“×™×§×ª × ×ª×™×‘ ×”×“×•×§×”: ××•×•×“× ×©×”-blob ×”×•× ×§×•×‘×¥ ×‘×ª×•×š ×”×ª×™×§×™×™×” ×‘×œ×‘×“
        if not blob.name.startswith(prefix) or blob.name == prefix or blob.size == 0:
            continue

        file_content_bytes = blob.download_as_bytes()

        # 1. ×—×™×œ×•×¥ ×˜×§×¡×˜
        content_string = extract_content(file_content_bytes, blob.name)

        # 2. ×—×™×ª×•×š ×˜×§×¡×˜ ×›×“×™ ×œ×× ×•×¢ ×©×’×™××ª TOKEN LIMIT (×’× ×× ×™×© ×§×‘×¦×™× ×¢× ×§×™×™× ×‘×ª×™×§×™×™×”)
        if len(content_string) > MAX_CHARS_PER_DOC:
            print(f"âš ï¸ Truncating file {blob.name} from {len(content_string)} chars to {MAX_CHARS_PER_DOC} chars.")
            content_string = content_string[:MAX_CHARS_PER_DOC]

        file_data.append({
            "name": blob.name,
            "content": content_string
        })

    print(f"âœ… Found {len(file_data)} files in directory '{directory_path}'.")
    return file_data


@app.route("/search", methods=["POST"])
def perform_search():
    try:
        data = request.json
        query = data.get("query")
        directory_path = data.get("directory_path")

        if not query or not directory_path:
            return jsonify({"error": "Missing 'query' or 'directory_path' in request."}), 400

        # 1. ×©×œ×™×¤×ª ××¡××›×™×
        documents = get_gcs_files(directory_path, BUCKET_NAME)

        if not documents:
            return jsonify({"result": "No documents found in the specified directory."}), 200

        # 2. ×”×›× ×ª Prompt ×¢×‘×•×¨ Gemini
        document_context = "\n\n--- DOCUMENTS ---\n\n"
        for doc in documents:
            document_context += f"File: {doc['name']}\nContent:\n{doc['content']}\n---\n"

        system_instruction = (
            "You are an expert document analyzer. "
            "Your task is to answer the user's query based ONLY on the provided documents. "
            "If the information is not present in the documents, state clearly that you cannot find the answer. "
            "Respond in the language of the query (Hebrew)."
        )

        full_prompt = (
            f"{document_context}\n\n"
            f"--- USER QUERY ---\n\n"
            f"Based on the files above, answer the following question: {query}"
        )

        # 3. ×§×¨×™××” ×œ-Gemini
        response = genai_client.models.generate_content(
            model='gemini-2.5-flash',
            contents=full_prompt,
            config={
                'system_instruction': system_instruction
            }
        )

        # 4. ×”×—×–×¨×ª ×”×ª×•×¦××•×ª
        return jsonify({
            "query": query,
            "directory": directory_path,
            "result": response.text,
            "status": "success"
        }), 200

    except ValueError as ve:
        print(f"ValueError: {ve}")
        return jsonify({"error": str(ve)}), 500
    except Exception as e:
        error_message = f"An unexpected error occurred during search: {e}"
        print(f"--- UNEXPECTED ERROR ---\n{error_message}\n{traceback.format_exc()}")
        return jsonify({"error": error_message}), 500


if __name__ == "__main__":
    app.run(debug=True, host="0.0.0.0", port=int(os.environ.get("PORT", 8080)))